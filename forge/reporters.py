"""
Compliance and policy reporting.

Generates human-readable and machine-readable reports for
policy validation results.
"""

from pathlib import Path
from typing import Any, Dict, List

from .utils import ensure_dir, timestamp, write_json


class ComplianceReporter:
    """
    Generates compliance reports from policy check results.

    Creates both JSON (machine-readable) and Markdown (human-readable)
    reports summarizing violations and warnings.
    """

    def __init__(self, output_dir: Path):
        """
        Initialize reporter.

        Args:
            output_dir: Directory for report output
        """
        self.output_dir = output_dir
        ensure_dir(output_dir)

    def generate_reports(self, violations: List[Any]) -> None:
        """
        Generate both JSON and Markdown reports.

        Args:
            violations: List of PolicyViolation objects or violation dictionaries
        """
        # Convert PolicyViolation objects to dicts if needed
        violation_dicts = []
        for v in violations:
            if hasattr(v, 'to_dict'):
                violation_dicts.append(v.to_dict())
            else:
                violation_dicts.append(v)

        self._generate_json_report(violation_dicts)
        self._generate_markdown_report(violation_dicts)

    def _generate_json_report(self, violations: List[Dict[str, Any]]) -> None:
        """Generate machine-readable JSON report."""
        report = {
            "generated_at": timestamp(),
            "summary": {
                "total_violations": len(violations),
                "errors": len([v for v in violations if v["severity"] == "error"]),
                "warnings": len([v for v in violations if v["severity"] == "warn"]),
            },
            "violations": sorted(violations, key=lambda v: (v["severity"], v["rule_id"])),
        }

        output_path = self.output_dir / "compliance.json"
        write_json(output_path, report)

    def _generate_markdown_report(self, violations: List[Dict[str, Any]]) -> None:
        """Generate human-readable Markdown report."""
        lines = [
            "# Workshop Compliance Report",
            "",
            f"**Generated:** {timestamp()}",
            "",
            "## Summary",
            "",
        ]

        errors = [v for v in violations if v["severity"] == "error"]
        warnings = [v for v in violations if v["severity"] == "warn"]

        if not violations:
            lines.extend([
                "✅ **All checks passed!** No violations found.",
                "",
            ])
        else:
            lines.extend([
                f"- **Total violations:** {len(violations)}",
                f"- **Errors:** {len(errors)} ❌",
                f"- **Warnings:** {len(warnings)} ⚠️",
                "",
            ])

        # Report errors
        if errors:
            lines.extend([
                "## Errors (Must Fix)",
                "",
            ])
            for violation in sorted(errors, key=lambda v: v["rule_id"]):
                lines.append(f"### ❌ {violation['rule_id']}")
                lines.append(f"**Message:** {violation['message']}")
                if violation.get("path"):
                    lines.append(f"**Path:** `{violation['path']}`")
                lines.append("")

        # Report warnings
        if warnings:
            lines.extend([
                "## Warnings (Should Fix)",
                "",
            ])
            for violation in sorted(warnings, key=lambda v: v["rule_id"]):
                lines.append(f"### ⚠️ {violation['rule_id']}")
                lines.append(f"**Message:** {violation['message']}")
                if violation.get("path"):
                    lines.append(f"**Path:** `{violation['path']}`")
                lines.append("")

        # Add footer
        lines.extend([
            "---",
            "",
            "*Generated by workshopforge policy engine*",
        ])

        output_path = self.output_dir / "compliance.md"
        output_path.write_text("\n".join(lines), encoding="utf-8")


def format_plan_report(plan: Dict[str, Any]) -> str:
    """
    Format AI plan as human-readable text.

    Args:
        plan: Plan dictionary with keys:
            - goal: User's stated goal
            - rationale: Why this approach
            - steps: List of step dicts (description, affected_files)
            - risks: List of potential policy violations

    Returns:
        Formatted plan text
    """
    lines = [
        "# AI Generation Plan",
        "",
        f"**Goal:** {plan.get('goal', 'Unknown')}",
        "",
        "## Rationale",
        "",
        plan.get("rationale", "No rationale provided"),
        "",
        "## Steps",
        "",
    ]

    for i, step in enumerate(plan.get("steps", []), 1):
        lines.append(f"### {i}. {step.get('description', 'Step')}")
        if step.get("affected_files"):
            lines.append("**Affected files:**")
            for path in step["affected_files"]:
                lines.append(f"  - `{path}`")
        lines.append("")

    if plan.get("risks"):
        lines.extend([
            "## Policy Risks",
            "",
        ])
        for risk in plan["risks"]:
            lines.append(f"- ⚠️ {risk}")
        lines.append("")

    lines.extend([
        "---",
        "",
        "*Review this plan before running `forge ai apply`*",
    ])

    return "\n".join(lines)
